<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gravity Model Simulation</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 960px; margin: auto; padding: 1rem; }
        #controls { margin-bottom: 2rem; display: flex; flex-wrap: wrap; gap: 1rem; }
        label { display: block; font-size: 0.9rem; }
        input[type=range] { width: 200px; }
    </style>
</head>
<body>
<h2>Gravity Model Simulation (Anderson & van Wincoop)</h2>
<div id="controls">
    <div>
        <label>GDP Orange: <input type="range" min="10" max="100" value="30" id="Y_orange"></label>
        <label>GDP Green: <input type="range" min="10" max="100" value="30" id="Y_green"></label>
        <label>GDP ROW: <input type="range" min="40" max="200" value="90" id="Y_row"></label>
    </div>
    <div>
        <label>Orange X: <input type="range" min="1" max="10" step="0.1" value="2.4" id="orange_x"></label>
        <label>Green X: <input type="range" min="1" max="10" step="0.1" value="8.0" id="green_x"></label>
        <label>ROW X Center: <input type="range" min="1" max="10" step="0.1" value="6.0" id="row_x"></label>
    </div>
    <div>
        <label>Sigma (σ): <input type="range" min="2" max="10" value="5" id="sigmaSlider"></label>
        <label>Tau Multiplier: <input type="range" min="0.5" max="2.5" step="0.1" value="1" id="tauMultSlider"></label>
        <label>Asymmetry: <input type="range" min="-1" max="1" step="0.1" value="0" id="asymSlider"></label>
        <label>Dispersion: <input type="range" min="0.0" max="2.5" step="0.1" value="0.5" id="dispersionSlider"></label>
    </div>
</div>
<div id="plot"></div>

<script>
function generateRowPositions(centerX, dispersion, seed=42) {
    const rng = mulberry32(seed);
    const offsets = Array(4).fill(0).map(() => [rng() * 2 - 1, rng() * 2 - 1].map(v => v * dispersion));
    return offsets.map(offset => [centerX + offset[0], 3.25 + offset[1]]);
}

function mulberry32(a) {
    return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

function computeFlows(Y_i, tau, sigma) {
    const N = Y_i.length;
    const Y_w = Y_i.reduce((a, b) => a + b, 0);
    const share = Y_i.map(y => y / Y_w);

    let Pi = Array(N).fill(1);
    let P = Array(N).fill(1);
    let maxIter = 50, tol = 1e-3, epsilon = 1e-9;

    for (let iter = 0; iter < maxIter; iter++) {
        let P_new = P.slice();
        let Pi_new = Pi.slice();

        for (let j = 0; j < N; j++) {
            let sum = 0;
            for (let i = 0; i < N; i++) {
                const ratio = tau[i][j] / Math.max(Pi[i], epsilon);
                sum += share[i] * Math.pow(ratio, 1 - sigma);
            }
            P[j] = Math.pow(sum, 1 / (1 - sigma));
        }

        for (let i = 0; i < N; i++) {
            let sum = 0;
            for (let j = 0; j < N; j++) {
                const ratio = tau[i][j] / Math.max(P[j], epsilon);
                sum += share[j] * Math.pow(ratio, 1 - sigma);
            }
            Pi[i] = Math.pow(sum, 1 / (1 - sigma));
        }

        const maxDiff = Math.max(...P.map((p, i) => Math.abs(p - P_new[i])));
        if (maxDiff < tol) break;
    }

    const flows = Array.from({length: N}, () => Array(N).fill(0));
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            const denom = Math.max(Pi[i] * P[j], epsilon);
            flows[i][j] = (Y_i[i] * Y_i[j] / Y_w) * Math.pow(tau[i][j] / denom, 1 - sigma);
        }
    }
    return { flows, Pi, P };
}

function drawPlot() {
    const Y_orange = parseFloat(document.getElementById("Y_orange").value);
    const Y_green = parseFloat(document.getElementById("Y_green").value);
    const Y_row = parseFloat(document.getElementById("Y_row").value);
    const orange_x = parseFloat(document.getElementById("orange_x").value);
    const green_x = parseFloat(document.getElementById("green_x").value);
    const row_x = parseFloat(document.getElementById("row_x").value);
    const sigma = parseFloat(document.getElementById("sigmaSlider").value);
    const tauMult = parseFloat(document.getElementById("tauMultSlider").value);
    const asym = parseFloat(document.getElementById("asymSlider").value);
    const dispersion = parseFloat(document.getElementById("dispersionSlider").value);

    const Y_k = Y_row * 0.25;
    const Y_l = Y_row * 0.25;
    const Y_m = Y_row * 0.25;
    const Y_n = Y_row * 0.25;
    const Y_i = [Y_orange, Y_green, Y_k, Y_l, Y_m, Y_n];
    const N = Y_i.length;
    const pos_orange = [orange_x, 3.25];
    const pos_green = [green_x, 3.25 + (Math.random() * 2 - 1) * dispersion];
    const row_positions = generateRowPositions(row_x, dispersion);
    const positions = [pos_orange, pos_green, ...row_positions];

    const tau = Array.from({length: N}, (_, i) =>
        Array.from({length: N}, (_, j) => {
            if (i === j) return 1;
            const dx = positions[j][0] - positions[i][0];
            const dy = positions[j][1] - positions[i][1];
            const d = Math.hypot(dx, dy);
            const direction = Math.sign(dx);
            const asym_factor = Math.max(0.5, 1 + asym * direction / 2);
            return (1 + d * tauMult / 4) * asym_factor;
        })
    );

    const { flows } = computeFlows(Y_i, tau, sigma);

    const labels = ['o', 'g', 'a', 'b', 'c', 'd'];
    const nodes = labels.map((l, i) => ({
        type: 'scatter',
        mode: 'markers+text',
        x: [positions[i][0]],
        y: [positions[i][1]],
        marker: { size: 10 + Math.sqrt(Y_i[i]) * 2, color: i === 0 ? 'orange' : i === 1 ? 'lightgreen' : 'skyblue' },
        text: [l],
        textposition: 'top center',
        showlegend: false
    }));

    const arrows = [];
    for (let i = 0; i < N; i++) {
        for (let j = 0; j < N; j++) {
            if (i !== j && flows[i][j] > 0.5) {
                arrows.push({
                    type: 'line',
                    x0: positions[i][0], y0: positions[i][1],
                    x1: positions[j][0], y1: positions[j][1],
                    line: {
                        width: Math.min(3, flows[i][j] / 5),
                        color: 'gray',
                        opacity: Math.min(1, flows[i][j] / 300)
                    }
                });
            }
        }
    }

    const layout = {
        title: `Gravity Model (σ=${sigma}, τ=${tauMult}, Asym=${asym})`,
        xaxis: { range: [0, 12], visible: false },
        yaxis: { range: [0, 6.5], visible: false },
        shapes: arrows,
        width: 900,
        height: 500
    };

    Plotly.newPlot('plot', nodes, layout);
}

Array.from(document.querySelectorAll("input[type=range]")).forEach(el => {
    el.addEventListener("input", drawPlot);
});

drawPlot();
</script>
</body>
</html>
