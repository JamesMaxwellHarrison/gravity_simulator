<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gravity Model Simulation</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body { font-family: Arial, sans-serif; max-width: 1000px; margin: auto; padding: 1rem; }
    #controls { margin-bottom: 2rem; display: flex; flex-wrap: wrap; gap: 1rem; }
    label { display: block; font-size: 0.9rem; }
    .slider-container { display: flex; align-items: center; gap: 0.5rem; }
    input[type=range] { width: 200px; }
    .value-label { width: 40px; text-align: left; }
    #equationBox { font-size: 1.2rem; margin-bottom: 1em; text-align: center; }
    #plot { margin-bottom: 2rem; }
    #table-container { font-family: monospace; white-space: pre; font-size: 1.1em; text-align: center; }
  </style>
</head>
<body>
<h2>Gravity Model Simulation (Anderson & van Wincoop)</h2>

<div id="controls">
  <div>
    <div class="slider-container"><label>GDP Orange:</label><input type="range" min="10" max="100" value="30" id="Y_orange"><span class="value-label" id="val_Y_orange">30</span></div>
    <div class="slider-container"><label>GDP Green:</label><input type="range" min="10" max="100" value="30" id="Y_green"><span class="value-label" id="val_Y_green">30</span></div>
    <div class="slider-container"><label>GDP ROW:</label><input type="range" min="40" max="200" value="90" id="Y_row"><span class="value-label" id="val_Y_row">90</span></div>
  </div>
  <div>
    <div class="slider-container"><label>Orange X:</label><input type="range" min="1" max="10" step="0.1" value="2.4" id="orange_x"><span class="value-label" id="val_orange_x">2.4</span></div>
    <div class="slider-container"><label>Green X:</label><input type="range" min="1" max="10" step="0.1" value="8.0" id="green_x"><span class="value-label" id="val_green_x">8.0</span></div>
    <div class="slider-container"><label>ROW X Center:</label><input type="range" min="1" max="10" step="0.1" value="6.0" id="row_x"><span class="value-label" id="val_row_x">6.0</span></div>
  </div>
  <div>
    <div class="slider-container"><label>Sigma (\u03c3):</label><input type="range" min="2" max="10" value="5" id="sigmaSlider"><span class="value-label" id="val_sigmaSlider">5</span></div>
    <div class="slider-container"><label>Tau Multiplier:</label><input type="range" min="0.5" max="2.5" step="0.1" value="1" id="tauMultSlider"><span class="value-label" id="val_tauMultSlider">1</span></div>
    <div class="slider-container"><label>Asymmetry:</label><input type="range" min="-1" max="1" step="0.1" value="0" id="asymSlider"><span class="value-label" id="val_asymSlider">0</span></div>
    <div class="slider-container"><label>Dispersion:</label><input type="range" min="0.0" max="2.5" step="0.1" value="0.5" id="dispersionSlider"><span class="value-label" id="val_dispersionSlider">0.5</span></div>
  </div>
  <div>
    <label>Table View:
      <select id="table_type">
        <option value="none">None</option>
        <option value="flows">Flows</option>
        <option value="tau">Tau</option>
      </select>
    </label>
  </div>
</div>

<div id="equationBox">
\[X_{og} = \left(\frac{Y_o \times Y_g}{Y_w}\right) \left(\frac{\tau_{og}}{\Pi_o \times P_g}\right)^{1-\sigma} = ?\]
</div>
<div id="plot"></div>
<div id="table-container"></div>

<script>
function updateSliderValues() {
  const ids = ["Y_orange", "Y_green", "Y_row", "orange_x", "green_x", "row_x", "sigmaSlider", "tauMultSlider", "asymSlider", "dispersionSlider"];
  ids.forEach(id => {
    document.getElementById("val_" + id).innerText = document.getElementById(id).value;
  });
}

Array.from(document.querySelectorAll("input[type=range]"))
  .forEach(el => el.addEventListener("input", updateSliderValues));
</script>
<script>

function generateRowPositions(centerX, dispersion, seed = 42) {
  const rng = mulberry32(seed);
  const offsets = Array(4).fill(0).map(() => [rng() * 2 - 1, rng() * 2 - 1].map(v => v * dispersion));
  return offsets.map(offset => [centerX + offset[0], 3.25 + offset[1]]);
}

function computeFlows(Y_i, tau, sigma) {
  const N = Y_i.length;
  const Y_w = Y_i.reduce((a, b) => a + b, 0);
  const share = Y_i.map(y => y / Y_w);
  let Pi = Array(N).fill(1);
  let P = Array(N).fill(1);
  const maxIter = 50, tol = 1e-3, epsilon = 1e-9;

  for (let iter = 0; iter < maxIter; iter++) {
    const P_new = [...P];
    const Pi_new = [...Pi];

    for (let j = 0; j < N; j++) {
      let sum = 0;
      for (let i = 0; i < N; i++) {
        const ratio = tau[i][j] / Math.max(Pi[i], epsilon);
        sum += share[i] * Math.pow(ratio, 1 - sigma);
      }
      P[j] = Math.pow(sum, 1 / (1 - sigma));
    }

    for (let i = 0; i < N; i++) {
      let sum = 0;
      for (let j = 0; j < N; j++) {
        const ratio = tau[i][j] / Math.max(P[j], epsilon);
        sum += share[j] * Math.pow(ratio, 1 - sigma);
      }
      Pi[i] = Math.pow(sum, 1 / (1 - sigma));
    }

    const maxDiff = Math.max(...P.map((p, i) => Math.abs(p - P_new[i])));
    if (maxDiff < tol) break;
  }

  const flows = Array.from({ length: N }, () => Array(N).fill(0));
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      const denom = Math.max(Pi[i] * P[j], 1e-9);
      flows[i][j] = (Y_i[i] * Y_i[j] / Y_w) * Math.pow(tau[i][j] / denom, 1 - sigma);
    }
  }
  return { flows, Pi, P };
}

function updateEquation(Y_o, Y_g, Y_w, tau_og, Pi_o, P_g, sigma, result) {
  const box = document.getElementById("equationBox");
  box.innerHTML = `\\[X_{og} = \left(\\frac{${Y_o.toFixed(1)} \\times ${Y_g.toFixed(1)}}{${Y_w.toFixed(1)}}\right) \left(\\frac{${tau_og.toFixed(2)}}{${Pi_o.toFixed(2)} \\times ${P_g.toFixed(2)}}\right)^{${(1 - sigma).toFixed(1)}} = ${result.toFixed(2)}\\]`;
  MathJax.typesetPromise();
}

function renderTable(data, labels, type) {
  const container = document.getElementById("table-container");
  if (type === "none") return container.innerText = "";
  const table = [];
  const n = labels.length;
  table.push("        " + labels.map(l => l.padStart(6)).join("") + "   Total");
  for (let i = 0; i < n; i++) {
    let row = labels[i].padEnd(6);
    let sum = 0;
    for (let j = 0; j < n; j++) {
      const val = type === 'flows' ? data.flows[i][j] : data.tau[i][j];
      sum += val;
      row += val.toFixed(1).padStart(6);
    }
    row += sum.toFixed(1).padStart(8);
    table.push(row);
  }
  container.innerText = table.join("\n");
}

function drawPlot() {
  const Y_orange = parseFloat(document.getElementById("Y_orange").value);
  const Y_green = parseFloat(document.getElementById("Y_green").value);
  const Y_row = parseFloat(document.getElementById("Y_row").value);
  const orange_x = parseFloat(document.getElementById("orange_x").value);
  const green_x = parseFloat(document.getElementById("green_x").value);
  const row_x = parseFloat(document.getElementById("row_x").value);
  const sigma = parseFloat(document.getElementById("sigmaSlider").value);
  const tauMult = parseFloat(document.getElementById("tauMultSlider").value);
  const asym = parseFloat(document.getElementById("asymSlider").value);
  const dispersion = parseFloat(document.getElementById("dispersionSlider").value);
  const tableType = document.getElementById("table_type").value;

  const Y_k = Y_row * 0.25, Y_l = Y_row * 0.25, Y_m = Y_row * 0.25, Y_n = Y_row * 0.25;
  const Y_i = [Y_orange, Y_green, Y_k, Y_l, Y_m, Y_n];
  const N = Y_i.length;
  const pos_orange = [orange_x, 3.25];
  const pos_green = [green_x, 3.35];
  const row_positions = generateRowPositions(row_x, dispersion);
  const positions = [pos_orange, pos_green, ...row_positions];
  const labels = ['o', 'g', 'a', 'b', 'c', 'd'];

  const tau = Array.from({ length: N }, (_, i) =>
    Array.from({ length: N }, (_, j) => {
      if (i === j) return 1;
      const dx = positions[j][0] - positions[i][0];
      const dy = positions[j][1] - positions[i][1];
      const d = Math.hypot(dx, dy);
      const direction = Math.sign(dx);
      const asym_factor = Math.max(0.5, 1 + asym * direction / 2);
      return (1 + d * tauMult / 4) * asym_factor;
    })
  );

  const { flows, Pi, P } = computeFlows(Y_i, tau, sigma);
  const gravity_val = (Y_i[0] * Y_i[1]) / (Y_i.reduce((a, b) => a + b)) * Math.pow(tau[0][1] / (Pi[0] * P[1]), 1 - sigma);

  updateEquation(Y_i[0], Y_i[1], Y_i.reduce((a, b) => a + b), tau[0][1], Pi[0], P[1], sigma, gravity_val);
  renderTable({ flows, tau }, labels, tableType);

  const nodes = labels.map((l, i) => ({
    type: 'scatter',
    mode: 'markers+text',
    x: [positions[i][0]],
    y: [positions[i][1]],
    marker: { size: (10 + Math.sqrt(Y_i[i]) * 2) * 4, color: i === 0 ? 'orange' : i === 1 ? 'lightgreen' : 'skyblue' },
    text: [l],
    textposition: 'top center',
    showlegend: false
  }));

  const arrows = [];
  for (let i = 0; i < N; i++) {
    for (let j = 0; j < N; j++) {
      if (i !== j && flows[i][j] > 0.5) {
        arrows.push({
          type: 'line',
          x0: positions[i][0], y0: positions[i][1],
          x1: positions[j][0], y1: positions[j][1],
          line: {
            width: Math.min(6, flows[i][j] / 2),
            color: 'gray',
            opacity: Math.min(1, flows[i][j] / 300)
          }
        });
      }
    }
  }

  const layout = {
    title: `Gravity Model (σ=${sigma}, τ=${tauMult}, Asym=${asym})`,
    xaxis: { range: [0, 12], visible: false },
    yaxis: { range: [0, 8.5], visible: false },
    shapes: arrows,
    width: 1200,
    height: 700
  };

  Plotly.newPlot('plot', nodes, layout);
}

Array.from(document.querySelectorAll("input, select")).forEach(el => el.addEventListener("input", drawPlot));
drawPlot();
updateSliderValues();
</script>
</body>
</html>
